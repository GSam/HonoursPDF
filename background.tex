\chapter{Background}\label{C:back} This chapter covers related background material which describes the body of related work and attempts to supply the relevant detail for those attempting to examine this document. In Section \ref{}, specific details about the Rust programming language and associated tools are explored. In Section \ref{}, the concept of refactoring is further elaborated and brief examination of early work in automated refactoring. In Section \ref{}, a number of existing refactoring tools are identified along with their respective approaches to perfomring refactorings, in particular tools related to Go and Scala. \section{Rust}To provide the necessary context for understanding the Rust specific terminology and concepts, this section explores some basic concepts within Rust. An important area for this work to highlight is the Rust compiler, known as rustc, which forms most of the enabling infrastructure that allows refactoring to occur.\subsection{Language features}\subsubsection{Traits}\subsubsection{Ownership}[Needs an example from the Rust docs... Based on the above example, the variable [x] owns the vector.]By default, Rust has `move semantics' where by assigning the value of one variable to another, the object is moved to the new variable and the old variable cannot be used to reference this object anymore. Performing cloning is another alternative, using clone(), along with traits that allow you to perform copies much like primitives (i32 or u32).Macro system?Redeclaring let bindings?Error handling (Option<>, Result<>, try!, panic())\subsection{The Rust compiler}As one of the most prominent examples of Rust code, the self-hosted Rust compiler, rustc, comprises of on the order of hundreds of thousands of lines of code. Due to the fact that it is written in Rust, the build process of the rustc occurs in multiple stages (with prior stages of the compiler compiling newer stages) and requires the download of a compatible snapshot of the Rust compiler (for stage 0) in order to compile correctly. In order to generate machine code, Rust relies on an LLVM backend [ref] and their associated LLVM IR (or intermediate representation).\subsubsection{Save-analysis}\subsubsection{Analysis of the csv output}Variable declaration:\begin{verbatim}variable,file_name,"basic_rename.rs",file_line,3,file_col,8,extent_start,38,extent_start_bytes,38,file_line_end,3,file_col_end,9,extent_end,39,extent_end_bytes,39,id,"13",name,"y",qualname,"y$13",value,"y = 20",type,"i32",scopeid,"0"\end{verbatim}\noindentVariable reference:\begin{verbatim}var_ref,file_name,"basic_rename.rs",file_line,10,file_col,20,extent_start,178,extent_start_bytes,178,file_line_end,10,file_col_end,21,extent_end,179,extent_end_bytes,179,refid,"13",refidcrate,"0",qualname,"",scopeid,"4"\end{verbatim}\subsubsection{Compilation stages}\subsubsection{Name resolution}The concept of paths A::B::C.\section{The background of refactoring}\subsection{The purpose of refactoring}\subsection{Fowler's take on refactoring}[Which refactorings should I describe? Just the ones I reference?]\subsection{Other paradigms}The Haskell refactoring tool for instance.\section{Approaches to refactoring}\subsection{The Go programming language}\subsubsection{gofmt tool}The gofmt tool was originally designed to pretty-print the AST for Go source code. This allowed developers to much more easily follow coding convention by using an automated tool to adjust their code. The gofmt tool was extended to allow a limited, but flexible refactoring capability. The tool functioned by parsing two Go compatible expressions as the input expression and the output expression. Any expressions which matched the input expression underwent the transformation into the corresponding output expression. This was more powerful than a simple text-replace because the expressions had to match the corresponding AST nodes and there was no need to account for other irrelevant details such as whitespace [which could be solved with a text replace, but would require more complicated regular expressions to match all the possible occurences]. This functionality of gofmt allowed the Go team to build the gofix tool which allowed Go user code to be fixed during the earlier stages of the language when the API had not been set entirely in stone yet.```Gofix has already made itself indispensable. In particular, the recent reflect changes would have been unpalatable without automated conversion, and the reflect API badly needed to be redone. Gofix gives us the ability to fix mistakes or completely rethink package APIs without worrying about the cost of converting existing code.''' -- Russ Cox\subsubsection{gorename tool}Although gofmt allows some checking of compatible transformations, they cannot always ensure that the resulting transformations would still compile or that new identifiers would not cause conflicts. Recently, the gorename tool has been created which allows the type safe renaming of most Go identifiers, whether they are type names or variables.Of course, the gofmt tool is much more flexible and performs more than renaming and helps to facilitate a number of the various refactorings highlighted by Fowler.\subsection{The Scala refactoring tool}Built as part of the master's thesis for Mirko Stocker [University of Applied Sciences Rapperswil ref?], the Scala refactoring tool forms one of the major refactoring tools for the Scala programmiing language. According to [http://scala-refactoring.org/] the currently suppported refactorings are renaming, extract local, inline local, extract method, organize imports and tentatively move class. The major focus of the master's thesis was the extract method refactoring, a non-trivial refactoring which allowed.\subsubsection{Overview of the approach}In this tool, the refactorings are built around a core library which is built around manipulating the AST. Analyzing the AST, the tool builds a number of indexes, including a global index in order to identify corresponding occurences of symbols in the AST. In this way the tool can identify both declarations and usages of different items, and do so as efficiency as possible using indexing. By manipulating the AST, the original source code can be manipulated arbitrarily and accurately in a way which will always continue to compile correctly. But notably, this relies on the ability for pretty-printing based on an AST.\subsubsection{Limitations}One of the major limitations of working solely with the AST is that the correspondence to the source code is somewhat lost in the process. Although pretty printing can occur, syntactic sugar within the language means that the resulting code may be significantly different to the original code and modify much more than the refactoring desired. Furthermore, certain constructs defined entirely in syntactic sugar cannot undergo refactoring due to their absence in the AST. The author does actively attempt to remedy this problem by applying an algorithm to line up the output code to the original source based on certain landmarks present in the text. However, this is not a trivial operation and serves as significant complexity being an operation which may not always succeed.\subsection{Java refactoring}Eclipse + IntelliJ IDEA. 