\chapter{Work Done}\label{C:wd}

\section{Design of Implementation}
% Redeclarations made under the same scope
% Every approach seems incredibly intrusive.

% With API changing, one of the first to implement anything which interfaces in this particular manner.

[Split into two chapters?]

% Why was it in Rust vs other languages? 
The choice of implementing the refactoring tool in Rust is for a number of reasons. Without a strong background in the language, performing even manual refactoring would likely be more difficult. The Rust compiler is a major component of the project and being able to modify the compiler and to understand the function of the compiler has been incredibly important. This is especially the case when documentation is not up to date and the level of support for some feature or API is unknown. It is also critical when there are bugs in the compiler that need to be fixed and extensions required to facilitate refactoring. The tool itself could also be used to test its own source code. Lastly, a number of API and interoperability problems would likely be a greater issue and so restricting compiler interactions with Rust code appears to be the best idea. 

While the tool is written in Rust, it also functions as a library and should allow for interoperability with any possible tool, GUI or otherwise. The choice of creating a library vs. a standalone tool has had a number of arguments back and forth, but at the moment, the functionality remains provided by a library-type interface. There are reasons that this may not be ideal, for instance, 

% Error propogation system in terms of nesting, expectations on thread serialization
% Throwing exceptions... no null types

Because of macros... you want to raise conflicts with new declaration.

\subsection{}
[Taken from http://scala-refactoring.org/wp-content/uploads/scala-refactoring.pdf, to transcribe]
\begin{enumerate}
\item provide a user interface so that a specific refactoring can be discovered and
invoked from the IDE.
\item analyze the program under refactoring to find out whether the refactoring is
applicable  and  further  to  determine  the  parameters  and  constraints  for  the
refactoring.
\item transform the program tree from its original form into a new – refactored – form
according to the refactoring’s configuration.
\item turn this new form back into source code,  keeping as much of the original
formatting in place as possible and to generate code for new parts of the program.
\item present the result of the refactoring to the user – typically in the form of a patch –
and apply it to the source code
\end{enumerate}

[Figure describe work flow of refactoring or structure of the library]

caching to provide multiple refactorings in a single run and to only run the save-analysis where necessary again. 

\subsection{}
\subsection{}

\section{Specifics of the Implementation}
\subsection{The changes to lib_resolve}
\subsubsection{The lack of inheritance}
\subsubsection{resolve_path termination}

\subsection{Unsuccessful attempts at refactorings?}
\subsubsection{Lessons learnt}